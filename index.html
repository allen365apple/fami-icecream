<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¨å®¶éœœæ·‡æ·‹æŒ‘æˆ°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overscroll-behavior: none;
            touch-action: none;
            background-color: #333;
        }
        
        .game-canvas {
            cursor: none;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .modal-animate {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center select-none">

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas" class="fixed inset-0 w-full h-full z-10 game-canvas"></canvas>

    <!-- UI å±¤ -->
    <div id="uiLayer" class="fixed inset-0 z-20 pointer-events-none flex flex-col justify-between p-6">
        <div class="text-center mt-2"></div>
        <div class="text-center mb-10">
             <p id="instructionText" class="text-blue-900 font-bold text-lg bg-white/90 px-6 py-2 rounded-full inline-block shadow-lg border-2 border-blue-200">
                ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆï¼è¨˜ä½è™›ç·šå½¢ç‹€ï¼
            </p>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="startScreen" class="fixed inset-0 z-30 bg-black/60 backdrop-blur-sm flex items-center justify-center">
        <div class="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-sm w-[90%] modal-animate border-b-8 border-blue-600">
            <div class="text-6xl mb-4">ğŸ¦</div>
            <h2 class="text-2xl font-black text-slate-800 mb-4 leading-tight">ä½ èƒ½æ“ å‡ºæ¼‚äº®çš„<br><span class="text-blue-600">å…¨å®¶éœœæ·‡æ·‹</span>å—ï¼Ÿ</h2>
            <p class="text-slate-600 mb-6 text-lg">
                <span class="text-sm text-slate-500">è¨˜æ†¶åŠ›å¤§è€ƒé©—ï¼<br><b>ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆ + é ‚éƒ¨æ”¶å°–</b><br>çœ‹å¥½è™›ç·šï¼Œé–‹å§‹å¾Œå°±æœƒæ¶ˆå¤±å–”ï¼</span>
            </p>
            <button id="startBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold py-4 px-10 rounded-full shadow-lg transform transition active:scale-95 w-full">
                é–‹å§‹æŒ‘æˆ°
            </button>
        </div>
    </div>

    <!-- çµç®—ç•«é¢ -->
    <div id="resultScreen" class="hidden fixed inset-0 z-40 bg-black/70 backdrop-blur-md flex items-center justify-center">
        <div class="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-sm w-[90%] modal-animate border-b-8 border-pink-400 relative">
            <div id="resultEmoji" class="text-7xl mb-2 absolute -top-12 left-1/2 transform -translate-x-1/2 drop-shadow-lg filter">ğŸ†</div>
            <h2 class="text-2xl font-bold text-slate-800 mt-6 mb-1">æª¢æ¸¬çµæœ</h2>
            
            <div class="mb-6 mt-8 py-4 bg-slate-50 rounded-xl border border-slate-100">
                <div class="text-sm text-slate-500 uppercase tracking-wider mb-1">ç¸½åˆ†</div>
                <div class="flex items-baseline justify-center gap-2">
                    <div id="scoreDisplay" class="text-8xl font-black text-blue-600">0</div>
                    <div class="text-2xl font-bold text-slate-400">/ 10</div>
                </div>
                <div id="titleDisplay" class="text-xl font-bold text-pink-500 mt-4 px-2">è¨ˆç®—ä¸­...</div>
            </div>

            <p id="commentDisplay" class="text-slate-600 mb-6 text-sm italic">è©•èª...</p>

            <button id="retryBtn" class="bg-pink-500 hover:bg-pink-600 text-white text-xl font-bold py-4 px-8 rounded-full shadow-lg transform transition active:scale-95 w-full flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                å†æŒ‘æˆ°ä¸€æ¬¡
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const startBtn = document.getElementById('startBtn');
        const retryBtn = document.getElementById('retryBtn');
        const instructionText = document.getElementById('instructionText');

        // éŠæˆ²ç‹€æ…‹
        let gameState = 'MENU';
        let isPressing = false;
        let hasStarted = false; 
        
        let width, height;
        let nozzle = { x: 0, y: 0, width: 60, height: 40 }; 
        let cone = { x: 0, y: 0, width: 0, height: 0 }; 
        
        let iceCreamStack = []; 
        let currentHeight = 0; 

        // æ“ºå‹•åµæ¸¬
        let lastConeX = 0;
        let direction = 0;
        let swingCount = 0; 
        let accumulatedMove = 0; 
        const SWING_THRESHOLD = 10;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            nozzle.x = width / 2;
            nozzle.y = 100; 
            nozzle.width = Math.min(80, width * 0.15);

            cone.width = 140 * (width < 600 ? 1.1 : 1);
            cone.height = 220 * (width < 600 ? 1.1 : 1);
            cone.y = height - cone.height + 30; 
            cone.x = width / 2;
            
            lastConeX = width / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        function resetGame() {
            iceCreamStack = [];
            hasStarted = false;
            isPressing = false;
            currentHeight = 0;
            cone.x = width / 2;
            lastConeX = width / 2;
            direction = 0;
            swingCount = 0;
            accumulatedMove = 0;
            instructionText.style.opacity = '1';
            instructionText.innerText = "ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆï¼è¨˜ä½è™›ç·šå½¢ç‹€ï¼";
        }

        function loop() {
            update();
            draw();
            if (gameState === 'PLAYING') {
                requestAnimationFrame(loop);
            }
        }

        function update() {
            if (!isPressing) return;

            hasStarted = true;
            instructionText.style.opacity = '0';

            // æ“ºå‹•åµæ¸¬
            let diff = cone.x - lastConeX;
            if (Math.abs(diff) > 0.5) {
                let currentDir = Math.sign(diff);
                if (currentDir !== direction) {
                    if (Math.abs(accumulatedMove) > SWING_THRESHOLD) {
                        swingCount++;
                        accumulatedMove = 0;
                    }
                    direction = currentDir;
                } else {
                    accumulatedMove += diff;
                }
            }
            lastConeX = cone.x;

            // é«˜åº¦æª¢æŸ¥
            const topY = cone.y - currentHeight;
            if (topY <= nozzle.y + 80) {
                finishSqueezing(); 
                return;
            }

            const dropX = width / 2; 
            const relativeOffset = dropX - cone.x; 

            // é€Ÿåº¦è¨­å®š
            const layerHeight = 6; 
            currentHeight += (layerHeight * 0.4); 

            // å¯¬åº¦è¨ˆç®—
            const cycleHeight = 60; // 60px ä¸€å¾ªç’°
            const phase = (currentHeight / cycleHeight) * Math.PI * 2;
            const wave = Math.sin(phase) * 4; 

            const baseLayerWidth = cone.width * 0.95; 
            let layerWidth = Math.max(40, baseLayerWidth - (iceCreamStack.length * 0.1) + wave);

            iceCreamStack.push({
                offset: relativeOffset,
                y: currentHeight,
                width: layerWidth,
                height: layerHeight,
                type: 'body' 
            });
        }

        function finishSqueezing() {
            isPressing = false;
            if (!hasStarted || iceCreamStack.length < 5) {
                endGame();
                return;
            }

            // æ”¶å°–è§’
            const lastLayer = iceCreamStack[iceCreamStack.length - 1];
            let tipOffset = lastLayer.offset; 
            let tipHeight = currentHeight;
            const startWidth = lastLayer.width;
            const tipSteps = 12; 
            
            for(let i=0; i<tipSteps; i++) {
                let progress = i / tipSteps;
                let w = (startWidth * 0.7) * (1 - Math.pow(progress, 0.5)); 
                if (w < 2) w = 2;
                let h = 6 + (progress * 4); 
                tipHeight += h * 0.8;
                iceCreamStack.push({
                    offset: tipOffset,
                    y: tipHeight,
                    width: w,
                    height: h,
                    type: 'tip'
                });
            }
            endGame();
        }

        // ç¹ªè£½å®Œç¾è™›ç·š (Ghost Shape) - å°–é ­ç‰ˆ
        function drawGhost() {
            if (hasStarted) return;

            ctx.save();
            ctx.translate(cone.x, cone.y);

            ctx.setLineDash([6, 6]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // åƒæ•¸è¨­å®š
            const layerH = 60; 
            const baseW = cone.width * 0.95; 
            
            ctx.beginPath();

            // å¾å·¦ä¸‹é–‹å§‹
            ctx.moveTo(-baseW/2, -5);

            // ç¹ªè£½å·¦å´æ³¢æµª (3å±¤)
            for(let i=0; i<3; i++) {
                let startY = -i * layerH;
                let endY = -(i+1) * layerH;
                let w1 = (baseW/2) - (i * 5);
                let w2 = (baseW/2) - ((i+1) * 5);
                
                ctx.bezierCurveTo(
                    -w1 - 10, startY - (layerH/3), 
                    -w2 - 10, endY + (layerH/3),
                    -w2, endY
                );
            }

            // ç¹ªè£½é ‚éƒ¨å°–ç«¯ (Pointy Tip)
            let topBodyY = -3 * layerH;
            let topW = (baseW/2) - (3 * 5);
            let tipHeight = 60; // å°–è§’é«˜åº¦
            
            // å·¦å´æ”¶å°–
            ctx.quadraticCurveTo(
                -topW + 5, topBodyY - 20, 
                0, topBodyY - tipHeight   
            );

            // å³å´æ”¶å°–
            ctx.quadraticCurveTo(
                topW - 5, topBodyY - 20, 
                topW, topBodyY           
            );

            // ç¹ªè£½å³å´æ³¢æµª (å°ç¨±)
            for(let i=2; i>=0; i--) {
                let startY = -(i+1) * layerH;
                let endY = -i * layerH;
                let w1 = (baseW/2) - ((i+1) * 5);
                let w2 = (baseW/2) - (i * 5);
                
                ctx.bezierCurveTo(
                    w1 + 10, startY + (layerH/3),
                    w2 + 10, endY - (layerH/3),
                    w2, endY - 5
                );
            }

            // åº•éƒ¨å°å£
            ctx.quadraticCurveTo(0, 10, -baseW/2, -5);

            ctx.stroke();
            
            // é«˜åº¦æŒ‡ç¤ºç·šèˆ‡æ–‡å­—
            ctx.font = 'bold 16px "Noto Sans TC"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.textAlign = 'center';
            
            let labelY = topBodyY - tipHeight;
            ctx.fillText("3.5 åœˆé«˜åº¦", 80, labelY + 30);
            
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.moveTo(80, labelY + 35);
            ctx.lineTo(10, labelY + 10); 
            ctx.stroke();

            ctx.restore();
        }

        function draw() {
            const grad = ctx.createLinearGradient(0, 0, width, height);
            grad.addColorStop(0, '#f0f9ff');
            grad.addColorStop(1, '#bfdbfe');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // Machine Body
            ctx.fillStyle = '#d1d5db';
            ctx.fillRect(width/2 - 150, 0, 300, height);
            const machineGrad = ctx.createLinearGradient(width/2-150, 0, width/2+150, 0);
            machineGrad.addColorStop(0, '#9ca3af');
            machineGrad.addColorStop(0.1, '#f3f4f6');
            machineGrad.addColorStop(0.5, '#e5e7eb');
            machineGrad.addColorStop(0.9, '#f3f4f6');
            machineGrad.addColorStop(1, '#9ca3af');
            ctx.fillStyle = machineGrad;
            ctx.fillRect(width/2 - 140, 20, 280, height-20);

            // LOGO
            ctx.save();
            ctx.fillStyle = '#0057a3'; 
            ctx.font = '900 28px "Noto Sans TC", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Fami!ce", width/2, nozzle.y - 50);
            ctx.restore();

            drawCone(cone.x, cone.y, cone.width, cone.height);

            // ç•«å®Œç¾è™›ç·š (å¦‚æœé‚„æ²’é–‹å§‹)
            drawGhost();

            ctx.fillStyle = '#fffdd0'; 
            ctx.shadowColor = 'rgba(0,0,0,0.1)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            
            for (let i = 0; i < iceCreamStack.length; i++) {
                let p = iceCreamStack[i];
                let drawX = cone.x + p.offset;
                let drawY = cone.y - p.y;
                ctx.beginPath();
                if (p.type === 'tip') {
                    ctx.ellipse(drawX, drawY, p.width / 2, p.height, 0, 0, Math.PI * 2);
                } else {
                    ctx.ellipse(drawX, drawY, p.width / 2, p.height * 1.3, 0, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            ctx.shadowColor = 'transparent';

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 5; i < iceCreamStack.length; i+=4) {
                let p = iceCreamStack[i];
                if (p.width < 15) continue; 
                let drawX = cone.x + p.offset - p.width/3;
                let drawY = cone.y - p.y;
                ctx.beginPath();
                ctx.ellipse(drawX, drawY, p.width / 8, p.height * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            if (isPressing) {
                let dropStartY = nozzle.y + 20;
                let dropEndY = cone.y; 
                if (iceCreamStack.length > 0) {
                    dropEndY = cone.y - iceCreamStack[iceCreamStack.length-1].y;
                }
                ctx.beginPath();
                ctx.moveTo(width/2 - 18, dropStartY); 
                ctx.lineTo(width/2 + 18, dropStartY);
                ctx.lineTo(width/2 + 14, dropEndY + 15); 
                ctx.lineTo(width/2 - 14, dropEndY + 15);
                ctx.fillStyle = '#fffdd0';
                ctx.fill();
            }

            drawNozzle(nozzle.x, nozzle.y, nozzle.width);
        }

        function drawNozzle(x, y, w) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#374151'; 
            ctx.beginPath();
            const spikes = 8; 
            const outerRadius = w/2;
            const innerRadius = w/3.5;
            for(let i=0; i<spikes*2; i++){
                const r = (i%2 === 0) ? outerRadius : innerRadius;
                const angle = (Math.PI / spikes) * i;
                const dx = Math.cos(angle) * r;
                const dy = Math.sin(angle) * r + 10;
                if(i===0) ctx.moveTo(dx, dy);
                else ctx.lineTo(dx, dy);
            }
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#6b7280';
            ctx.beginPath();
            ctx.moveTo(-w/2 - 5, -40);
            ctx.lineTo(w/2 + 5, -40);
            ctx.lineTo(w/2 + 5, 10);
            ctx.lineTo(-w/2 - 5, 10);
            ctx.fill();
            ctx.fillStyle = '#0057a3';
            ctx.fillRect(-w/2 - 5, -35, w + 10, 10);
            ctx.restore();
        }

        function drawCone(x, y, w, h) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.moveTo(-w/2, 0);
            ctx.lineTo(w/2, 0);
            ctx.lineTo(0, h);
            ctx.closePath();
            let coneGrad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
            coneGrad.addColorStop(0, '#d97706'); 
            coneGrad.addColorStop(0.5, '#fbbf24');
            coneGrad.addColorStop(1, '#b45309');
            ctx.fillStyle = coneGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(146, 64, 14, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=1; i<6; i++) {
                let xPos = (w/2) * (i/6);
                ctx.moveTo(-xPos, 0);
                ctx.lineTo(0, h * (1 - i/6));
                ctx.moveTo(xPos, 0);
                ctx.lineTo(0, h * (1 - i/6));
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(0, 0, w/2 + 4, 10, 0, 0, Math.PI*2);
            ctx.fillStyle = '#d97706';
            ctx.fill();
            ctx.restore();
        }

        function endGame() {
            gameState = 'FINISHED';
            
            const bodyStack = iceCreamStack.filter(p => p.type === 'body');
            const count = bodyStack.length;
            
            if (count < 10) {
                showResult(0, "è©¦åƒå“ï¼Ÿ", "é€™é€£ä¸€å£éƒ½ä¸å¤ åƒï¼", "ğŸ‘»");
                return;
            }

            // === 10åˆ†åˆ¶è©•åˆ† ===
            const oneTurnHeight = 60; 
            let totalBodyHeight = bodyStack[bodyStack.length-1].y;
            let turns = totalBodyHeight / oneTurnHeight;

            let maxOffset = 0;
            bodyStack.forEach(p => {
                if(Math.abs(p.offset) > maxOffset) maxOffset = Math.abs(p.offset);
            });
            let offsetRatio = maxOffset / cone.width;

            let score = 0;

            // 1. åœˆæ•¸ (ç›®æ¨™ 3.5)
            let turnDiff = Math.abs(turns - 3.5);
            if (turnDiff <= 0.2) { 
                score += 5; 
            } else if (turnDiff <= 0.5) {
                score += 3; 
            } else {
                score += 1; 
            }

            // 2. ç©©å®šåº¦ & æ¬¡æ•¸
            if (offsetRatio <= 0.15) {
                score += 3;
            } else if (offsetRatio <= 0.25) {
                score += 1;
            } else {
                score -= 1;
            }

            if (swingCount === 3 || swingCount === 4) {
                score += 2;
            }

            if (score > 10) score = 10;
            if (score < 1) score = 1;

            // ç¨±è™Ÿ
            let title, comment, emoji;
            
            if (score === 10) {
                title = "å…¨å®¶æ¦®è­½åº—é•·";
                comment = "å®Œç¾é‡ç¾ï¼é‚£å€‹å°–è§’å¤ªç¾äº†ï¼";
                emoji = "ğŸ‘‘";
            } else if (score >= 8) {
                title = "è³‡æ·±åº—å“¡";
                comment = "å¾ˆæ£’ï¼3.5 åœˆæŠ“å¾—å¾ˆæº–ã€‚";
                emoji = "âœ¨";
            } else if (score >= 6) {
                title = "åˆæ ¼å·¥è®€ç”Ÿ";
                comment = "é‚„ä¸éŒ¯ï¼Œä½†è¦å†æ›´åƒè™›ç·šä¸€é»ã€‚";
                emoji = "ğŸ˜";
            } else if (score >= 4) {
                title = "æ–°æ‰‹ä¸Šè·¯";
                comment = "æ³¨æ„é«˜åº¦ï¼Œä¸è¦æ“ å¤ªå¤šæˆ–å¤ªå°‘ã€‚";
                emoji = "ğŸ’ª";
            } else {
                title = "æ‰‹æ»‘å¤§å¸«";
                comment = "å½¢ç‹€å®Œå…¨è·‘æ‰äº†å•¦ï¼";
                emoji = "ğŸ“‰";
            }

            showResult(score, title, comment, emoji);
        }

        function showResult(score, title, comment, emoji) {
            document.getElementById('scoreDisplay').innerText = score;
            document.getElementById('titleDisplay').innerText = title;
            document.getElementById('commentDisplay').innerText = comment;
            document.getElementById('resultEmoji').innerText = emoji;
            
            setTimeout(() => {
                resultScreen.classList.remove('hidden');
            }, 500);
        }

        function handleStart(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            isPressing = true;
            updateConePos(e);
        }

        function handleMove(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            updateConePos(e);
        }

        function handleEnd(e) {
            if (gameState !== 'PLAYING') return;
            if (isPressing) {
                finishSqueezing();
            }
        }

        function updateConePos(e) {
            let clientX;
            if (e.touches) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            cone.x = Math.max(cone.width/2, Math.min(width - cone.width/2, clientX));
        }

        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
            loop();
        });

        retryBtn.addEventListener('click', () => {
            resultScreen.classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
            loop();
        });

        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        canvas.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);

    </script>
</body>
</html>
