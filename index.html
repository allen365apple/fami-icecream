<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¨å®¶éœœæ·‡æ·‹æŒ‘æˆ°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overscroll-behavior: none;
            touch-action: none;
            background-color: #f1f5f9;
        }
        
        .game-canvas {
            cursor: none;
        }

        @keyframes simplePop {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .modal-animate {
            animation: simplePop 0.2s ease-out forwards;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center select-none bg-slate-200">

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas" class="fixed inset-0 w-full h-full z-10 game-canvas"></canvas>

    <!-- UI å±¤ (éŠæˆ²ä¸­) -->
    <div id="uiLayer" class="fixed inset-0 z-20 pointer-events-none flex flex-col justify-between p-6">
        <div class="text-center mt-2"></div>
        <div class="text-center mb-10">
             <p id="instructionText" class="text-blue-900 font-bold text-lg bg-white/90 px-6 py-2 rounded-full inline-block shadow-lg border-2 border-blue-200">
                ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆï¼è¨˜ä½è™›ç·šå½¢ç‹€ï¼
            </p>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="startScreen" class="fixed inset-0 z-30 bg-black/60 flex items-center justify-center">
        <div class="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-sm w-[90%] modal-animate border-b-8 border-blue-600">
            <div class="text-6xl mb-4">ğŸ¦</div>
            <h2 class="text-2xl font-black text-slate-800 mb-4 leading-tight">ä½ èƒ½æ“ å‡ºæ¼‚äº®çš„<br><span class="text-blue-600">å…¨å®¶éœœæ·‡æ·‹</span>å—ï¼Ÿ</h2>
            <p class="text-slate-600 mb-6 text-lg">
                <span class="text-sm text-slate-500">æŒ‘æˆ°è·äººæ‰‹æ„Ÿï¼<br><b>ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆ + é ‚éƒ¨æ”¶å°–</b><br>çœ‹å¥½è™›ç·šï¼Œé–‹å§‹å¾Œå°±æœƒæ¶ˆå¤±å–”ï¼</span>
            </p>
            <button id="startBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold py-4 px-10 rounded-full shadow-lg transform transition active:scale-95 w-full">
                é–‹å§‹æŒ‘æˆ°
            </button>
        </div>
    </div>

    <!-- çµç®—ç•«é¢ (å«æˆªåœ–) -->
    <div id="resultScreen" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/70">
        <div class="bg-white p-6 rounded-3xl shadow-2xl w-[90%] max-w-md modal-animate border-t-8 border-blue-500 relative">
            
            <!-- æ¨™é¡Œ -->
            <div class="text-center mb-4">
                <h2 id="titleDisplay" class="text-2xl font-black text-slate-800">ç¨±è™Ÿè¼‰å…¥ä¸­...</h2>
                <p id="commentDisplay" class="text-slate-500 text-sm mt-1">è©•èª...</p>
            </div>

            <!-- æ ¸å¿ƒå…§å®¹ï¼šå·¦åˆ†æ•¸ å³ç…§ç‰‡ -->
            <div class="flex flex-row items-center justify-center gap-4 mb-6 bg-slate-50 p-4 rounded-2xl border border-slate-100">
                <!-- å·¦å´ï¼šåˆ†æ•¸ -->
                <div class="flex-1 text-center">
                    <div class="text-xs text-slate-400 font-bold uppercase tracking-wider mb-1">æœ¬æ¬¡å¾—åˆ†</div>
                    <div class="text-7xl font-black text-blue-600 leading-none" id="scoreDisplay">0</div>
                    <div class="text-xl font-bold text-slate-300 mt-1">/ 10</div>
                </div>

                <!-- å³å´ï¼šéœœæ·‡æ·‹ç¸®åœ– (è‡ªå‹•æ“·å– Canvas) -->
                <div class="w-28 h-40 bg-white rounded-xl border-4 border-white shadow-md overflow-hidden relative transform rotate-2">
                    <img id="resultSnapshot" class="w-full h-full object-cover object-bottom bg-slate-200" alt="ä½ çš„æˆå“">
                    <div class="absolute top-0 right-0 bg-red-500 text-white text-[10px] font-bold px-1 rounded-bl-lg">NEW</div>
                </div>
            </div>

            <!-- æŒ‰éˆ• -->
            <button id="retryBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold py-3 px-6 rounded-xl shadow-lg transform transition active:scale-95 flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                å†ç©ä¸€æ¬¡
            </button>

            <!-- è£é£¾ Emoji -->
            <div id="resultEmoji" class="absolute -top-8 -right-4 text-6xl drop-shadow-lg transform rotate-12">ğŸ†</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        // å„ªåŒ–ï¼šé—œé–‰ alpha é€šé“ä»¥æå‡å°‘è¨±æ•ˆèƒ½ï¼Œä½†è‹¥éœ€è¦é€æ˜èƒŒæ™¯å‰‡éœ€é–‹å•Ÿ
        // é€™è£¡æˆ‘å€‘èƒŒæ™¯æ˜¯å¯¦è‰²çš„ï¼Œæ‰€ä»¥ alpha: false æ˜¯å®‰å…¨çš„å„ªåŒ–
        const ctx = canvas.getContext('2d', { alpha: false });
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const startBtn = document.getElementById('startBtn');
        const retryBtn = document.getElementById('retryBtn');
        const instructionText = document.getElementById('instructionText');
        const resultSnapshot = document.getElementById('resultSnapshot');

        let gameState = 'MENU';
        let isPressing = false;
        let hasStarted = false; 
        let animationId = null; 
        
        let width, height;
        let nozzle = { x: 0, y: 0, width: 60, height: 40 }; 
        let cone = { x: 0, y: 0, width: 0, height: 0 }; 
        
        let iceCreamStack = []; 
        let currentHeight = 0; 

        let lastConeX = 0;
        let direction = 0;
        let swingCount = 0; 
        let accumulatedMove = 0; 
        const SWING_THRESHOLD = 10;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            nozzle.x = width / 2;
            nozzle.y = 100; 
            nozzle.width = Math.min(80, width * 0.15);

            cone.width = 140 * (width < 600 ? 1.1 : 1);
            cone.height = 220 * (width < 600 ? 1.1 : 1);
            cone.y = height - cone.height + 30; 
            cone.x = width / 2;
            
            lastConeX = width / 2;
            
            if(gameState !== 'PLAYING') draw();
        }
        window.addEventListener('resize', resize);
        resize();

        function resetGame() {
            iceCreamStack = [];
            hasStarted = false;
            isPressing = false;
            currentHeight = 0;
            cone.x = width / 2;
            lastConeX = width / 2;
            direction = 0;
            swingCount = 0;
            accumulatedMove = 0;
            instructionText.style.opacity = '1';
            instructionText.innerText = "ç›®æ¨™ï¼šå®Œç¾ 3.5 åœˆï¼è¨˜ä½è™›ç·šå½¢ç‹€ï¼";
        }

        function loop() {
            if (gameState !== 'PLAYING') return; 

            update();
            draw();
            animationId = requestAnimationFrame(loop);
        }

        function update() {
            if (!isPressing) return;

            hasStarted = true;
            instructionText.style.opacity = '0';

            let diff = cone.x - lastConeX;
            if (Math.abs(diff) > 0.5) {
                let currentDir = Math.sign(diff);
                if (currentDir !== direction) {
                    if (Math.abs(accumulatedMove) > SWING_THRESHOLD) {
                        swingCount++;
                        accumulatedMove = 0;
                    }
                    direction = currentDir;
                } else {
                    accumulatedMove += diff;
                }
            }
            lastConeX = cone.x;

            const topY = cone.y - currentHeight;
            if (topY <= nozzle.y + 80) {
                finishSqueezing(); 
                return;
            }

            const dropX = width / 2; 
            const relativeOffset = dropX - cone.x; 

            const layerHeight = 6; 
            currentHeight += (layerHeight * 0.4); 

            const cycleHeight = 60; 
            const phase = (currentHeight / cycleHeight) * Math.PI * 2;
            const wave = Math.sin(phase) * 4; 

            const baseLayerWidth = cone.width * 0.95; 
            let layerWidth = Math.max(40, baseLayerWidth - (iceCreamStack.length * 0.1) + wave);

            iceCreamStack.push({
                offset: relativeOffset,
                y: currentHeight,
                width: layerWidth,
                height: layerHeight,
                type: 'body' 
            });
        }

        function finishSqueezing() {
            isPressing = false;
            if (!hasStarted || iceCreamStack.length < 5) {
                endGame();
                return;
            }

            const lastLayer = iceCreamStack[iceCreamStack.length - 1];
            let tipOffset = lastLayer.offset; 
            let tipHeight = currentHeight;
            const startWidth = lastLayer.width;
            const tipSteps = 12; 
            
            for(let i=0; i<tipSteps; i++) {
                let progress = i / tipSteps;
                let w = (startWidth * 0.7) * (1 - Math.pow(progress, 0.5)); 
                if (w < 2) w = 2;
                let h = 6 + (progress * 4); 
                tipHeight += h * 0.8;
                iceCreamStack.push({
                    offset: tipOffset,
                    y: tipHeight,
                    width: w,
                    height: h,
                    type: 'tip'
                });
            }
            endGame();
        }

        function drawGhost() {
            if (hasStarted) return;

            ctx.save();
            ctx.translate(cone.x, cone.y);

            ctx.setLineDash([6, 6]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            const layerH = 60; 
            const baseW = cone.width * 0.95; 
            
            ctx.beginPath();
            ctx.moveTo(-baseW/2, -5);

            for(let i=0; i<3; i++) {
                let startY = -i * layerH;
                let endY = -(i+1) * layerH;
                let w1 = (baseW/2) - (i * 5);
                let w2 = (baseW/2) - ((i+1) * 5);
                
                ctx.bezierCurveTo(
                    -w1 - 10, startY - (layerH/3), 
                    -w2 - 10, endY + (layerH/3),
                    -w2, endY
                );
            }

            let topBodyY = -3 * layerH;
            let topW = (baseW/2) - (3 * 5);
            let tipHeight = 60; 
            
            ctx.quadraticCurveTo(-topW + 5, topBodyY - 20, 0, topBodyY - tipHeight);
            ctx.quadraticCurveTo(topW - 5, topBodyY - 20, topW, topBodyY);

            for(let i=2; i>=0; i--) {
                let startY = -(i+1) * layerH;
                let endY = -i * layerH;
                let w1 = (baseW/2) - ((i+1) * 5);
                let w2 = (baseW/2) - (i * 5);
                
                ctx.bezierCurveTo(
                    w1 + 10, startY + (layerH/3),
                    w2 + 10, endY - (layerH/3),
                    w2, endY - 5
                );
            }

            ctx.quadraticCurveTo(0, 10, -baseW/2, -5);
            ctx.stroke();
            
            ctx.font = 'bold 16px "Noto Sans TC"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.textAlign = 'center';
            let labelY = topBodyY - tipHeight;
            ctx.fillText("3.5 åœˆé«˜åº¦", 80, labelY + 30);
            
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.moveTo(80, labelY + 35);
            ctx.lineTo(10, labelY + 10); 
            ctx.stroke();

            ctx.restore();
        }

        function draw() {
            const grad = ctx.createLinearGradient(0, 0, width, height);
            grad.addColorStop(0, '#f0f9ff');
            grad.addColorStop(1, '#bfdbfe');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = '#d1d5db';
            ctx.fillRect(width/2 - 150, 0, 300, height);
            const machineGrad = ctx.createLinearGradient(width/2-150, 0, width/2+150, 0);
            machineGrad.addColorStop(0, '#9ca3af');
            machineGrad.addColorStop(0.1, '#f3f4f6');
            machineGrad.addColorStop(0.5, '#e5e7eb');
            machineGrad.addColorStop(0.9, '#f3f4f6');
            machineGrad.addColorStop(1, '#9ca3af');
            ctx.fillStyle = machineGrad;
            ctx.fillRect(width/2 - 140, 20, 280, height-20);

            ctx.save();
            ctx.fillStyle = '#0057a3'; 
            ctx.font = '900 28px "Noto Sans TC", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Fami!ce", width/2, nozzle.y - 50);
            ctx.restore();

            drawCone(cone.x, cone.y, cone.width, cone.height);

            drawGhost();

            ctx.fillStyle = '#fffdd0';
            // æ¢å¾©é™°å½±æ•ˆæœ (ç”¨æˆ¶è¦æ±‚)
            ctx.shadowColor = 'rgba(0,0,0,0.1)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            
            // å„ªåŒ–ç¹ªåœ–é‚è¼¯ä¿®æ­£ï¼š
            // èº«é«”éƒ¨åˆ†(body)æ¯éš”ä¸€å±¤ç•«ä¸€æ¬¡ä»¥ç¯€çœæ•ˆèƒ½
            // å°–ç«¯éƒ¨åˆ†(tip)ç‚ºäº†å¹³æ»‘æ„Ÿï¼Œæ¯ä¸€å±¤éƒ½è¦ç•«
            for (let i = 0; i < iceCreamStack.length; i++) {
                let p = iceCreamStack[i];

                // é—œéµä¿®æ­£ï¼šå¦‚æœæ˜¯ body ä¸”æ˜¯å¥‡æ•¸å±¤ï¼Œå°±è·³éä¸ç•«
                if (p.type === 'body' && i % 2 !== 0) continue;

                let drawX = cone.x + p.offset;
                let drawY = cone.y - p.y;
                ctx.beginPath();
                if (p.type === 'tip') {
                    ctx.ellipse(drawX, drawY, p.width / 2, p.height, 0, 0, Math.PI * 2);
                } else {
                    ctx.ellipse(drawX, drawY, p.width / 2, p.height * 1.3, 0, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            // é—œé–‰é™°å½±ï¼Œé¿å…å½±éŸ¿å¾ŒçºŒç¹ªè£½
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // æ¢å¾©é«˜å…‰ï¼Œé€™ä¸å½±éŸ¿å¤ªå¤šæ•ˆèƒ½ä½†å¢åŠ è³ªæ„Ÿ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 5; i < iceCreamStack.length; i+=4) {
                let p = iceCreamStack[i];
                if (p.width < 15) continue; 
                let drawX = cone.x + p.offset - p.width/3;
                let drawY = cone.y - p.y;
                ctx.beginPath();
                ctx.ellipse(drawX, drawY, p.width / 8, p.height * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            if (isPressing) {
                let dropStartY = nozzle.y + 20;
                let dropEndY = cone.y; 
                if (iceCreamStack.length > 0) {
                    dropEndY = cone.y - iceCreamStack[iceCreamStack.length-1].y;
                }
                ctx.beginPath();
                ctx.moveTo(width/2 - 18, dropStartY); 
                ctx.lineTo(width/2 + 18, dropStartY);
                ctx.lineTo(width/2 + 14, dropEndY + 15); 
                ctx.lineTo(width/2 - 14, dropEndY + 15);
                ctx.fillStyle = '#fffdd0';
                ctx.fill();
            }

            drawNozzle(nozzle.x, nozzle.y, nozzle.width);
        }

        function drawNozzle(x, y, w) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#374151'; 
            ctx.beginPath();
            const spikes = 8; 
            const outerRadius = w/2;
            const innerRadius = w/3.5;
            for(let i=0; i<spikes*2; i++){
                const r = (i%2 === 0) ? outerRadius : innerRadius;
                const angle = (Math.PI / spikes) * i;
                const dx = Math.cos(angle) * r;
                const dy = Math.sin(angle) * r + 10;
                if(i===0) ctx.moveTo(dx, dy);
                else ctx.lineTo(dx, dy);
            }
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#6b7280';
            ctx.beginPath();
            ctx.moveTo(-w/2 - 5, -40);
            ctx.lineTo(w/2 + 5, -40);
            ctx.lineTo(w/2 + 5, 10);
            ctx.lineTo(-w/2 - 5, 10);
            ctx.fill();
            ctx.fillStyle = '#0057a3';
            ctx.fillRect(-w/2 - 5, -35, w + 10, 10);
            ctx.restore();
        }

        function drawCone(x, y, w, h) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.moveTo(-w/2, 0);
            ctx.lineTo(w/2, 0);
            ctx.lineTo(0, h);
            ctx.closePath();
            let coneGrad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
            coneGrad.addColorStop(0, '#d97706'); 
            coneGrad.addColorStop(0.5, '#fbbf24');
            coneGrad.addColorStop(1, '#b45309');
            ctx.fillStyle = coneGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(146, 64, 14, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=1; i<6; i++) {
                let xPos = (w/2) * (i/6);
                ctx.moveTo(-xPos, 0);
                ctx.lineTo(0, h * (1 - i/6));
                ctx.moveTo(xPos, 0);
                ctx.lineTo(0, h * (1 - i/6));
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(0, 0, w/2 + 4, 10, 0, 0, Math.PI*2);
            ctx.fillStyle = '#d97706';
            ctx.fill();
            ctx.restore();
        }

        function endGame() {
            gameState = 'FINISHED';
            cancelAnimationFrame(animationId); 
            draw(); 

            try {
                const dataURL = canvas.toDataURL("image/png");
                resultSnapshot.src = dataURL;
            } catch (e) {
                console.error("Screenshot failed", e);
            }
            
            const bodyStack = iceCreamStack.filter(p => p.type === 'body');
            const count = bodyStack.length;
            
            if (count < 10) {
                showResult(0, "è©¦åƒå“ï¼Ÿ", "é€™é€£ä¸€å£éƒ½ä¸å¤ åƒï¼", "ğŸ‘»");
                return;
            }

            const oneTurnHeight = 60; 
            let totalBodyHeight = bodyStack[bodyStack.length-1].y;
            let turns = totalBodyHeight / oneTurnHeight;

            let maxOffset = 0;
            bodyStack.forEach(p => {
                if(Math.abs(p.offset) > maxOffset) maxOffset = Math.abs(p.offset);
            });
            let offsetRatio = maxOffset / cone.width;

            let score = 0;

            if (turns >= 3.3 && turns <= 3.7) { 
                score += 5; // å®Œç¾å€é–“ç¸®å°
            } else if (turns >= 3.0 && turns <= 4.0) {
                score += 3; 
            } else {
                score += 1; 
            }

            if (offsetRatio <= 0.15) {
                score += 3;
            } else if (offsetRatio <= 0.25) {
                score += 1;
            } else {
                score -= 1;
            }

            if (swingCount === 3 || swingCount === 4) {
                score += 2;
            }

            if (score > 10) score = 10;
            if (score < 1) score = 1;

            let title, comment, emoji;
            
            if (score === 10) {
                title = "å…¨å®¶æ¦®è­½åº—é•·";
                comment = "å®Œç¾é‡ç¾ï¼é‚£å€‹å°–è§’å¤ªç¾äº†ï¼";
                emoji = "ğŸ‘‘";
            } else if (score >= 8) {
                title = "è³‡æ·±åº—å“¡";
                comment = "å¾ˆæ£’ï¼3.5 åœˆæŠ“å¾—å¾ˆæº–ã€‚";
                emoji = "âœ¨";
            } else if (score >= 6) {
                title = "åˆæ ¼å·¥è®€ç”Ÿ";
                comment = "é‚„ä¸éŒ¯ï¼Œä½†è¦å†æ›´åƒè™›ç·šä¸€é»ã€‚";
                emoji = "ğŸ˜";
            } else if (score >= 4) {
                title = "æ–°æ‰‹ä¸Šè·¯";
                comment = "æ³¨æ„é«˜åº¦ï¼Œä¸è¦æ“ å¤ªå¤šæˆ–å¤ªå°‘ã€‚";
                emoji = "ğŸ’ª";
            } else {
                title = "æ‰‹æ»‘å¤§å¸«";
                comment = "å½¢ç‹€å®Œå…¨è·‘æ‰äº†å•¦ï¼";
                emoji = "ğŸ“‰";
            }

            showResult(score, title, comment, emoji);
        }

        function showResult(score, title, comment, emoji) {
            document.getElementById('scoreDisplay').innerText = score;
            document.getElementById('titleDisplay').innerText = title;
            document.getElementById('commentDisplay').innerText = comment;
            document.getElementById('resultEmoji').innerText = emoji;
            
            // ç¸®çŸ­å»¶é²æ™‚é–“ç‚º 0.5 ç§’ (500ms)
            setTimeout(() => {
                resultScreen.classList.remove('hidden');
            }, 500);
        }

        function handleStart(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            isPressing = true;
            updateConePos(e);
        }

        function handleMove(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            updateConePos(e);
        }

        function handleEnd(e) {
            if (gameState !== 'PLAYING') return;
            if (isPressing) {
                finishSqueezing();
            }
        }

        function updateConePos(e) {
            let clientX;
            if (e.touches) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            cone.x = Math.max(cone.width/2, Math.min(width - cone.width/2, clientX));
        }

        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
            loop();
        });

        retryBtn.addEventListener('click', () => {
            resultScreen.classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
            loop();
        });

        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        canvas.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);

        resize();
        draw();

    </script>
</body>
</html>
